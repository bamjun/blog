## 콜백 지옥(Callback Hell)

![image](https://github.com/bamjun/blog/assets/21354840/57412ac8-2478-40e1-8629-4a4aebe3202e)


"콜백 지옥(Callback Hell)" 또는 "콜백 피라미드(Pyramid of Doom)"는 자바스크립트와 같은 비동기 프로그래밍에서 발생할 수 있는 문제의 일종입니다. 이 현상은 여러 콜백 함수들이 중첩되고, 서로 얽혀 복잡한 구조를 형성할 때 발생합니다. 이러한 구조는 코드의 가독성을 떨어뜨리고, 유지보수를 어렵게 만들며, 오류 처리와 디버깅을 복잡하게 만듭니다.

### 콜백 지옥의 특징

- **중첩된 구조**: 비동기 작업이 완료된 후 실행되는 콜백 함수 내부에서 또 다른 비동기 작업을 수행하고, 이런 패턴이 반복되면서 코드가 깊이 중첩됩니다.
- **가독성 저하**: 코드가 길고 중첩된 구조를 가지게 되면 이해하기 어렵고 가독성이 떨어집니다.
- **오류 처리의 어려움**: 중첩된 콜백 구조에서는 오류 처리가 어렵고, 오류가 발생했을 때 어느 부분에서 문제가 발생했는지 추적하기 어렵습니다.
- **디버깅의 복잡성**: 코드의 흐름이 복잡해지고, 디버깅이 어려워집니다.

### 콜백 지옥 해결 방법

1. **프로미스(Promises) 사용**: ES6에서 도입된 프로미스는 콜백 지옥을 해결하는 데 유용한 방법입니다. 프로미스는 비동기 작업을 대기열에 넣고, 작업이 완료되면 결과를 반환합니다. `.then()`과 `.catch()` 메서드를 통해 비동기 작업의 성공과 실패를 각각 처리할 수 있습니다.

2. **async/await 사용**: ES2017에서 도입된 `async`와 `await` 키워드는 비동기 코드를 동기 코드처럼 간결하고 이해하기 쉽게 작성할 수 있게 해줍니다. `async` 함수는 항상 프로미스를 반환하며, `await` 키워드는 프로미스의 결과가 반환될 때까지 함수 실행을 일시 중지합니다.

3. **모듈화**: 복잡한 비동기 로직을 작은 함수 단위로 나누어 모듈화함으로써 가독성을 높이고 관리하기 쉽게 만듭니다.

4. **라이브러리 활용**: 비동기 흐름을 쉽게 관리할 수 있는 라이브러리(예: Bluebird, Async.js 등)를 사용하여 복잡한 비동기 코드를 구조화하고 관리합니다.

콜백 지옥은 자바스크립트에서 흔히 마주치는 문제이지만, 위와 같은 방법을 통해 효과적으로 해결할 수 있습니다.

---
---
프로미스(Promises)는 자바스크립트에서 비동기 연산을 다룰 때 사용되는 객체입니다. 프로미스는 비동기 작업이 완료되었을 때의 결과를 나타내며, 그 결과는 성공(`fulfilled`)이거나 실패(`rejected`)일 수 있습니다. 프로미스는 비동기 연산이 끝난 후에 일어날 일들을 더 쉽고 관리하기 좋은 방식으로 체이닝할 수 있게 해줍니다.

### 프로미스의 상태

1. **Pending(대기 중)**: 초기 상태로, 아직 결과가 정해지지 않은 상태입니다.
2. **Fulfilled(이행됨)**: 연산이 성공적으로 완료되었을 때의 상태입니다.
3. **Rejected(거부됨)**: 연산이 실패했을 때의 상태입니다.

### 프로미스의 사용법

```javascript
// 프로미스 생성
const myPromise = new Promise((resolve, reject) => {
  // 비동기 작업 수행
  const condition = true; // 가정
  if (condition) {
    resolve("성공"); // 성공 시
  } else {
    reject("실패"); // 실패 시
  }
});

// 프로미스 사용
myPromise
  .then((result) => {
    console.log(result); // '성공'이 출력됨
  })
  .catch((error) => {
    console.error(error); // '실패'가 출력됨
  });
```

### 프로미스의 장점

- **비동기 처리의 복잡성 감소**: 콜백 함수의 중첩 문제(콜백 지옥)를 해결하고, 코드의 가독성을 높여줍니다.
- **에러 처리 용이성**: `.catch()` 메서드를 사용하여 비동기 작업 중 발생한 에러를 쉽게 처리할 수 있습니다.
- **여러 비동기 작업의 조합**: `Promise.all()` 등의 메서드를 사용하여 여러 비동기 작업을 효율적으로 조합하고 관리할 수 있습니다.

프로미스는 현대 자바스크립트에서 비동기 프로그래밍의 핵심 개념 중 하나이며, `async/await` 구문과 함께 사용되어 더욱 간결하고 이해하기 쉬운 비동기 코드를 작성할 수 있도록 도와줍니다.



`async/await`는 자바스크립트의 현대적인 비동기 처리 패턴입니다. 이 구문은 ES2017(ES8)에 도입되었으며, `Promise`를 더 간결하고 동기적인 방식으로 처리할 수 있게 해줍니다. `async/await`를 사용하면 비동기 코드를 마치 동기 코드처럼 쉽게 작성하고 읽을 수 있습니다.

### async 키워드

- `async` 키워드는 함수 앞에 위치합니다. 이를 사용하면 해당 함수는 항상 프로미스를 반환합니다.
- 함수 내부에서 일어나는 비동기 연산들은 여전히 비동기적으로 수행되지만, 함수의 반환 값은 프로미스로 감싸져 반환됩니다.

### await 키워드

- `await` 키워드는 `async` 함수 내에서만 사용할 수 있습니다.
- `await`은 프로미스가 이행(`fulfilled`)되거나 거부(`rejected`)될 때까지 함수의 실행을 일시 중지합니다. 이행된 경우, 프로미스의 결과 값으로 함수 실행이 재개됩니다.
- `await`은 프로미스의 완료를 기다리는 동안 다른 스크립트 코드가 블록되지 않고 계속 실행될 수 있게 합니다.

### 예제

```javascript
async function fetchData() {
  try {
    const response = await fetch('https://api.example.com/data');
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error('Error fetching data:', error);
  }
}

fetchData();
```

위 예제에서 `fetchData` 함수는 `async` 함수입니다. `fetch` 호출에 `await`를 사용하여 프로미스의 완료를 기다리고, 결과를 변수에 할당합니다. 이 패턴은 비동기 연산을 동기식 코드처럼 쉽게 읽고 작성할 수 있게 해줍니다.

### 에러 처리

`try...catch` 구문을 사용하여 `async/await` 패턴에서 발생할 수 있는 예외를 적절히 처리할 수 있습니다. 이를 통해 비동기 연산 중 발생하는 에러를 잡아내고, 필요한 대응을 할 수 있습니다.

`async/await`는 코드의 가독성을 크게 향상시키고, 복잡한 비동기 로직을 쉽게 관리할 수 있게 해줍니다.
