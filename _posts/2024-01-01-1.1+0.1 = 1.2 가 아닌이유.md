## 1.1+0.1 = 1.2 가 아닌이유

Python의 `decimal` 모듈은 부동소수점 연산의 정확성 문제를 해결하기 위해 설계되었습니다. 이 모듈은 더 정확한 소수점 연산을 제공하며, 금융과 같이 정밀한 계산이 필요한 분야에서 유용하게 사용됩니다. `decimal.Decimal` 객체를 사용하여 소수점 연산의 정확도를 높일 수 있습니다.

다만, `decimal.Decimal`을 사용할 때 중요한 점은 부동소수점 리터럴이 아니라 문자열을 사용해서 초기화하는 것이 좋다는 점입니다. 이는 부동소수점 리터럴이 이미 오차를 포함하고 있을 수 있기 때문입니다. 예를 들어, `1.1`과 `0.1`은 실제로는 정확한 1.1과 0.1이 아닐 수 있습니다.

따라서, `decimal.Decimal(1.1)` 또는 `decimal.Decimal(0.1)` 대신 `decimal.Decimal('1.1')` 또는 `decimal.Decimal('0.1')`과 같이 문자열을 사용하여 초기화하는 것이 정확도를 보장합니다.

아래 예제는 이를 보여줍니다:

```python
from decimal import Decimal

# 정확한 연산을 위해 문자열을 사용
a = Decimal('1.1')
b = Decimal('0.1')
c = Decimal('1.2')

# 비교 연산
result = a + b == c

print(result)  # 이 결과는 True가 됩니다.
```

위 코드는 `Decimal` 객체를 문자열로 초기화하여, `1.1 + 0.1`이 정확히 `1.2`와 같은지 비교합니다. 이 방법은 부동소수점 연산에서 발생하는 일반적인 오차를 방지합니다.

---

Python에서 `decimal.Decimal` 모듈을 사용하는 이유와 방식에 대해 좀 더 자세히 설명해 드리겠습니다.

### 왜 `decimal.Decimal`을 사용하는가?

1. **부동소수점 오차 문제**: 컴퓨터는 이진수를 사용하여 숫자를 표현합니다. 이 때문에, 일부 소수(특히 10진수 기반의 소수)는 정확하게 표현되지 않고 근사치로 처리됩니다. 예를 들어, `1.1`이라는 소수는 이진 표현에서 완벽하게 표현할 수 없는 숫자입니다. 이는 일반적인 부동소수점 타입(float)을 사용할 때 오차를 발생시킬 수 있습니다.

2. **금융 계산의 정확성**: 특히 금융과 같이 소수점 이하의 정확한 계산이 중요한 분야에서는 이러한 오차가 큰 문제가 될 수 있습니다. `decimal.Decimal`은 이러한 계산에 있어서 더 높은 정확도를 제공합니다.

### `decimal.Decimal` 사용 방법

- **문자열 초기화**: `Decimal`은 부동소수점 숫자보다 문자열을 이용해 초기화하는 것이 좋습니다. 이는 이미 오차를 포함할 수 있는 부동소수점 리터럴 대신 정확한 값으로 초기화하기 위함입니다.

- **정밀도 설정**: `Decimal`은 사용자가 필요에 따라 정밀도를 설정할 수 있게 해줍니다. 이를 통해 계산의 정확도를 제어할 수 있습니다.

### 예제 코드

```python
from decimal import Decimal

# 문자열을 이용한 초기화
a = Decimal('1.1')
b = Decimal('0.1')
c = Decimal('1.2')

# 연산
result = a + b

# 결과 비교
print("결과:", result)
print("1.2와 동일한가?", result == c)
```

이 코드는 `1.1`과 `0.1`을 `Decimal` 객체로 정확하게 표현하고, 이들의 합이 `1.2`와 정확히 일치하는지 비교합니다. 이 방식은 일반적인 부동소수점 연산에서 발생할 수 있는 오차를 방지합니다.

이러한 특징 때문에 `decimal.Decimal`은 정확한 소수점 연산이 필요한 금융, 과학, 공학 계산에 주로 사용됩니다.


===

숫자 `1.1`의 이진수 표현을 이해하려면 먼저 부동소수점 표현 방식을 이해해야 합니다. 컴퓨터는 실수를 이진 부동소수점 형태로 표현합니다. 이 방식은 정수 부분과 소수 부분을 이진수로 변환하여 저장합니다. 하지만 모든 십진수 소수를 완벽하게 이진수로 변환할 수 있는 것은 아니며, `1.1`과 같은 숫자는 정확한 이진 표현이 불가능합니다.

이진수에서 `1.1`과 같은 십진수를 근사하여 표현하려면, 먼저 정수 부분과 소수 부분을 분리하여 변환합니다.

1. **정수 부분(1)**: 이진수로 `1`입니다.
2. **소수 부분(.1)**: 이진수로 변환하려면, 2를 곱하는 과정을 반복합니다.
   
   0.1(10진수) * 2 = 0.2 → 0
   0.2(10진수) * 2 = 0.4 → 0
   0.4(10진수) * 2 = 0.8 → 0
   0.8(10진수) * 2 = 1.6 → 1
   0.6(10진수) * 2 = 1.2 → 1
   ...

   이 과정은 무한히 계속되며, 정확히 0.1을 표현하지 못합니다.

이진수에서 `1.1`은 대략 `1.0001100110011001100110011001100110011001100110011...`과 같이 무한히 반복되는 근사값으로 표현됩니다. 이는 `1`과 `0.0001100110011001100110011001100110011001100110011...`을 더한 값과 같습니다.

컴퓨터는 이러한 반복되는 소수점을 메모리에 저장할 때 일정 길이까지만 저장하고 나머지를 잘라냅니다. 이로 인해 근사치가 발생하며, 이는 부동소수점 연산에서의 오차의 원인이 됩니다.

따라서, `1.1`을 이진수로 완벽하게 정확히 표현하는 것은 불가능하며, 대신 근사값을 사용합니다. 이 근사값은 언어와 시스템에 따라 약간씩 다를 수 있습니다.
